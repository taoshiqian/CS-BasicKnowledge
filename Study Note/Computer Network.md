# 计算机网络

### TCP/IP五层网络协议

1. 应用层：（应用层，表示层，回话层）HTTP, HTTPS, DNS, RPC, DHCP, P2P, RTMP, GTP
2. 传输层：UDP, TCP
3. 网络层：IP, ICMP, BGP, OSPF, GRE, IPSec
4. 链路层：ARP, VLAN, STP
5. 物理层：网络跳线

举个例子，投简历给贵公司

应用层：DHCP协议给用户机器配置IP地址。浏览器输入一个URL，要知道如何去访问该网站，则使用地址簿协议DNS去查找（或者HTTPDNS），得到该URL对应的IP地址，IP地址则可以看做门牌号。浏览器对该网站做出请求，使用HTTP协议（需要加密传输的使用HTTPS），比如“我的基本信息和目标岗位”。经过应用层封装，浏览器将这些包交给下一层（socket编程实现）。

传输层：无连接UDP，面向连接TCP。TCP中包含浏览器监听端口和电商服务器监听端口，操作系统通过**端口**来判断它的包应该给哪个**进程**。

网络层：IP协议。包含了源**IP地址**（浏览器所在），目标IP地址（电商服务器）。由于距离可能很远，网关（一般是路由器）收到包之后，通过路由表查找到下一个IP应该是哪。这些路由协议常用的有OSPF，BGP。

链路层：ARP协议根据IP地址得到**MAC地址**。

![五层协议里面的内容](./images/网络五层协议.png)

到了服务器。MAC验证正确，取下链路层的MAC，发送给操作系统的网络层，IP验证正确，取下IP头，交给传输层（即TCP），TCP回复确认信息，说“我收到了”原路返回给浏览器，我就看到我投递成功了。如果没收到确认信息，我（发送端）的TCP层就会重新发送这个包，还是经过一样的过程，知道收到确认信息。重发的操作浏览器不需要参与，TCP自己保障重传。除非连接断了才需要浏览器的应用层重新发起请求。顺利到达TCP后，取出端口号，找到对应进程，将信息发给它。进程就可以得到其中的http请求，收到了我的信息，服务器后台做对应的处理，并给客户端回消息。

告诉相关进程通过RPC调用（远程过程调用）。

![五层协议过程](./images/五层协议过程.jpg)

### 网络为什么要分层



### TCP与UDP的区别

1. TCP面向连接，UDP面向无连接。

   所谓的建立连接：建立一定的数据结构来维护双方交互的状态

2. TCP提供可靠交互，无差错、不丢失、不重复、有序。UDP继承了IP包的特性，丢失与无序都可能发生。

3. TCP面向字节流（没头没尾）。UDP继承了IP的特性，基于数据包，一个个地发送，一个个地接受。

4. TCP有拥塞控制，网络环境不好则会调整自己的发送行为。UDP则应用层让它发就会发。

5. TCP是有状态服务，精确记录着发送了什么接收了什么。UDP无状态服务，发出去了就不管了。

### UDP三大使用场景

1. 需要资源少、网络情况好的内网、对丢包不敏感的应用。DHCP基于UDP，一般获取IP地址都是内网请求，且一次获取不到IP没关系，可以多次请求。
2. 不需要一对一沟通，可以广播、组播的应用。DHCP基于UDP广播。
3. 需要速度快、延时低、可以少量丢包，即便网络拥塞也要传输的应用。语音、视频。

QUIC：Quick UDP Internet Connections，快速UDP互联网连接。Google提出基于UDP改进的通信协议，降低网络通信延迟。QUIC属于应用层协议，自己实现快速建立连接、减少重传、减小延时、自适应拥塞控制。

直播协议，丢包没关系，能跟上就好

实时游戏，必须实时够快，才有游戏感

IoT物联网，资源少，TCP消耗大 ，所以选择UDP

移动通信，4G网络协议GTP-U则是基于UDP的，因为它自己有复杂的机制，TCP就过于冗余了

### TCP的可靠性

1. 源端口和目标端口（UDP也有）
2. 包的序号，防止乱序
3. 确认序号，防止丢失，超时重传机制
4. 面向连接的状态位：SYN发起连接，ACK回复/确认，RST重新连接，FIN结束连接
5. 流量控制，通信双方各声明一个窗口，标识自己当前的处理能力，别发的太快或者太慢
6. 拥塞控制，在网络不好的时候进行 慢开始和快重传

##### TCP超时重传

自适应重传算法，计算RTT，（一般成两倍更新）

##### TCP流量控制

发送端和接受端分别有缓存（即窗口），滑动窗口

##### TCP拥塞控制

**慢开始** ： 速度指数级增长。到了一定阈值，线性增长。

**快重传**：  1.速度降成1，阈值成一半，然后实行慢开始策略。2.阈值成一半，降到阈值，线性增长。

![慢开始与快重传](./images/慢开始与快重传.jpg)

### 三次握手

![三次握手](./images/三次握手.jpg)

**请求->应答->应答之应答**: 一开始，客户端和服务端都处于CLOSED状态。服务端监控某端口，处理LISTEN状态。客户端主动发起连接SYN，处于SYN-SENT状态。服务端收到请求，返回SYN，并且ACK客户端的SYN，处于SYN-RECD状态。客户端收到SYN和ACK，发送ACK的ACK，处于ESTABLISHED状态。服务端收到ACK的ACK之后，处于ESTABLISHED状态。

为什么不是两次：

为什么不是四次：>=3都行，但是浪费资源了

### 四次挥手

![四次挥手](./images/四次挥手.jpg)

A先请求断开，处于FIN_WAIT_1状态，B收到消息，回复ACK表示知道了，进入CLOSE_WAIT状态。A收到ACK，进入FIN_WAIT_2状态。

B直到自己该发的消息发完之后，请求断开FIN，进入LAST_ACK状态。A收到请求后，回复ACK表示指标了，进入TIME-WAIT状态，等待2MSL，因为B若没收到ACK，会重新请求，等待完成就CLOSE。B收到ACK就会CLOSE。

**MSL**：Maximum Segment Lifetime 报文最大生存时间，超过该时间的报文会被丢弃。TCP报文是基于IP协议的，IP头中有TTL域用来表示可以经过的最大路由数，没经过一次路由就减一，减到0则会被丢弃，同时发送ICMP报文通知源主机。

若B超过了2MSL依旧没收到他FIN的ACK，B按照TCP原理会重发FIN，A再次收到后，表示依旧等那么久了，可以直接断开了，则会直接发送RST然后断开，B也明白了，断开。

### 为什么需要四次挥手

TCP是**全双工模式**：A发送完数据之后请求断开，但B仍有数据要发，A仍需要接受数据。所有前两次握手，当A收到B的ACK之后，进入FIN_WAIT状态，等待B的主动关闭，即后两次握手。

### TCP状态机

![TCP状态机](./images/TCP状态机.jpg)

